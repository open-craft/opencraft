/* tslint:disable */
/* eslint-disable */
/**
 * OpenCraft Instance Manager
 * API for OpenCraft Instance Manager
 *
 * The version of the OpenAPI document: api
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    Account,
    AccountFromJSON,
    AccountToJSON,
    GenericAPIError,
    GenericAPIErrorFromJSON,
    GenericAPIErrorToJSON,
    LogoFaviconUpload,
    LogoFaviconUploadFromJSON,
    LogoFaviconUploadToJSON,
    OpenEdXInstanceConfig,
    OpenEdXInstanceConfigFromJSON,
    OpenEdXInstanceConfigToJSON,
    OpenEdXInstanceConfigUpdate,
    OpenEdXInstanceConfigUpdateFromJSON,
    OpenEdXInstanceConfigUpdateToJSON,
    OpenEdXInstanceDeploymentCreate,
    OpenEdXInstanceDeploymentCreateFromJSON,
    OpenEdXInstanceDeploymentCreateToJSON,
    OpenEdXInstanceDeploymentStatus,
    OpenEdXInstanceDeploymentStatusFromJSON,
    OpenEdXInstanceDeploymentStatusToJSON,
    ThemeSchema,
    ThemeSchemaFromJSON,
    ThemeSchemaToJSON,
    Token,
    TokenFromJSON,
    TokenToJSON,
    TokenError,
    TokenErrorFromJSON,
    TokenErrorToJSON,
    TokenObtainPair,
    TokenObtainPairFromJSON,
    TokenObtainPairToJSON,
    TokenRefresh,
    TokenRefreshFromJSON,
    TokenRefreshToJSON,
    TokenVerify,
    TokenVerifyFromJSON,
    TokenVerifyToJSON,
    ValidationError,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface AccountsCreateRequest {
    data: Account;
}

export interface AccountsPartialUpdateRequest {
    username: string;
    data: Account;
}

export interface AccountsUpdateRequest {
    username: string;
    data: Account;
}

export interface AuthRefreshCreateRequest {
    data: TokenRefresh;
}

export interface AuthTokenCreateRequest {
    data: TokenObtainPair;
}

export interface AuthVerifyCreateRequest {
    data: TokenVerify;
}

export interface InstancesOpenedxConfigCreateRequest {
    data: OpenEdXInstanceConfig;
}

export interface InstancesOpenedxConfigImageRequest {
    id: string;
    logo?: Blob;
    favicon?: Blob;
}

export interface InstancesOpenedxConfigPartialUpdateRequest {
    id: string;
    data: OpenEdXInstanceConfigUpdate;
}

export interface InstancesOpenedxConfigReadRequest {
    id: string;
}

export interface InstancesOpenedxConfigThemeConfigRequest {
    id: string;
    data: ThemeSchema;
}

export interface InstancesOpenedxConfigUpdateRequest {
    id: string;
    data: OpenEdXInstanceConfig;
}

export interface InstancesOpenedxConfigValidateRequest {
    data: OpenEdXInstanceConfig;
}

export interface InstancesOpenedxDeploymentCreateRequest {
    data: OpenEdXInstanceDeploymentCreate;
    force?: boolean;
}

export interface InstancesOpenedxDeploymentDeleteRequest {
    id: string;
}

export interface InstancesOpenedxDeploymentReadRequest {
    id: string;
}

/**
 * no description
 */
export class V2Api extends runtime.BaseAPI {

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Create new user registration
     */
    async accountsCreateRaw(requestParameters: AccountsCreateRequest): Promise<runtime.ApiResponse<Account>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling accountsCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/accounts/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AccountToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Create new user registration
     */
    async accountsCreate(requestParameters: AccountsCreateRequest): Promise<Account> {
        const response = await this.accountsCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Get current user registration data
     */
    async accountsListRaw(): Promise<runtime.ApiResponse<Array<Account>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/accounts/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(AccountFromJSON));
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Get current user registration data
     */
    async accountsList(): Promise<Array<Account>> {
        const response = await this.accountsListRaw();
        return await response.value();
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Update current user registration data
     */
    async accountsPartialUpdateRaw(requestParameters: AccountsPartialUpdateRequest): Promise<runtime.ApiResponse<Account>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling accountsPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling accountsPartialUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/accounts/{username}/`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: AccountToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Update current user registration data
     */
    async accountsPartialUpdate(requestParameters: AccountsPartialUpdateRequest): Promise<Account> {
        const response = await this.accountsPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Update current user registration data
     */
    async accountsUpdateRaw(requestParameters: AccountsUpdateRequest): Promise<runtime.ApiResponse<Account>> {
        if (requestParameters.username === null || requestParameters.username === undefined) {
            throw new runtime.RequiredError('username','Required parameter requestParameters.username was null or undefined when calling accountsUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling accountsUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/accounts/{username}/`.replace(`{${"username"}}`, encodeURIComponent(String(requestParameters.username))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: AccountToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => AccountFromJSON(jsonValue));
    }

    /**
     * User account management API.  This API can be used to register users, and to access user registration information for the current user.
     * Update current user registration data
     */
    async accountsUpdate(requestParameters: AccountsUpdateRequest): Promise<Account> {
        const response = await this.accountsUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * This overrides the method just to add the Swagger schema overrides
     * Refresh a JWT auth token from refresh token.
     */
    async authRefreshCreateRaw(requestParameters: AuthRefreshCreateRequest): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling authRefreshCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/auth/refresh/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenRefreshToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * This overrides the method just to add the Swagger schema overrides
     * Refresh a JWT auth token from refresh token.
     */
    async authRefreshCreate(requestParameters: AuthRefreshCreateRequest): Promise<Token> {
        const response = await this.authRefreshCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * This overrides the method just to add the Swagger schema overrides
     * Generate a JWT auth token from user credentials.
     */
    async authTokenCreateRaw(requestParameters: AuthTokenCreateRequest): Promise<runtime.ApiResponse<Token>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling authTokenCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/auth/token/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenObtainPairToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenFromJSON(jsonValue));
    }

    /**
     * This overrides the method just to add the Swagger schema overrides
     * Generate a JWT auth token from user credentials.
     */
    async authTokenCreate(requestParameters: AuthTokenCreateRequest): Promise<Token> {
        const response = await this.authTokenCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * This overrides the method just to add the Swagger schema overrides
     * Check if a JWT auth token is valid.
     */
    async authVerifyCreateRaw(requestParameters: AuthVerifyCreateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling authVerifyCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/auth/verify/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: TokenVerifyToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This overrides the method just to add the Swagger schema overrides
     * Check if a JWT auth token is valid.
     */
    async authVerifyCreate(requestParameters: AuthVerifyCreateRequest): Promise<void> {
        await this.authVerifyCreateRaw(requestParameters);
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Create new user instance.
     */
    async instancesOpenedxConfigCreateRaw(requestParameters: InstancesOpenedxConfigCreateRequest): Promise<runtime.ApiResponse<OpenEdXInstanceConfig>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling instancesOpenedxConfigCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenEdXInstanceConfigToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenEdXInstanceConfigFromJSON(jsonValue));
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Create new user instance.
     */
    async instancesOpenedxConfigCreate(requestParameters: InstancesOpenedxConfigCreateRequest): Promise<OpenEdXInstanceConfig> {
        const response = await this.instancesOpenedxConfigCreateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Send a POST to action image/ with the file in the `logo` or `favicon` field to add or update it.
     * Endpoint for saving favicon or logo images
     */
    async instancesOpenedxConfigImageRaw(requestParameters: InstancesOpenedxConfigImageRequest): Promise<runtime.ApiResponse<LogoFaviconUpload>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxConfigImage.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.logo !== undefined) {
            formParams.append('logo', requestParameters.logo as any);
        }

        if (requestParameters.favicon !== undefined) {
            formParams.append('favicon', requestParameters.favicon as any);
        }

        const response = await this.request({
            path: `/v2/instances/openedx_config/{id}/image/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => LogoFaviconUploadFromJSON(jsonValue));
    }

    /**
     * Send a POST to action image/ with the file in the `logo` or `favicon` field to add or update it.
     * Endpoint for saving favicon or logo images
     */
    async instancesOpenedxConfigImage(requestParameters: InstancesOpenedxConfigImageRequest): Promise<LogoFaviconUpload> {
        const response = await this.instancesOpenedxConfigImageRaw(requestParameters);
        return await response.value();
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Get all instances owned by user
     */
    async instancesOpenedxConfigListRaw(): Promise<runtime.ApiResponse<Array<OpenEdXInstanceConfig>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenEdXInstanceConfigFromJSON));
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Get all instances owned by user
     */
    async instancesOpenedxConfigList(): Promise<Array<OpenEdXInstanceConfig>> {
        const response = await this.instancesOpenedxConfigListRaw();
        return await response.value();
    }

    /**
     * This API can be used to manage the configuration for Open edX instances owned by clients.
     * Open edX Instance Configuration API.
     */
    async instancesOpenedxConfigPartialUpdateRaw(requestParameters: InstancesOpenedxConfigPartialUpdateRequest): Promise<runtime.ApiResponse<OpenEdXInstanceConfigUpdate>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxConfigPartialUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling instancesOpenedxConfigPartialUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: OpenEdXInstanceConfigUpdateToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenEdXInstanceConfigUpdateFromJSON(jsonValue));
    }

    /**
     * This API can be used to manage the configuration for Open edX instances owned by clients.
     * Open edX Instance Configuration API.
     */
    async instancesOpenedxConfigPartialUpdate(requestParameters: InstancesOpenedxConfigPartialUpdateRequest): Promise<OpenEdXInstanceConfigUpdate> {
        const response = await this.instancesOpenedxConfigPartialUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Get an instance owned by user
     */
    async instancesOpenedxConfigReadRaw(requestParameters: InstancesOpenedxConfigReadRequest): Promise<runtime.ApiResponse<OpenEdXInstanceConfig>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxConfigRead.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenEdXInstanceConfigFromJSON(jsonValue));
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Get an instance owned by user
     */
    async instancesOpenedxConfigRead(requestParameters: InstancesOpenedxConfigReadRequest): Promise<OpenEdXInstanceConfig> {
        const response = await this.instancesOpenedxConfigReadRaw(requestParameters);
        return await response.value();
    }

    /**
     * This is a custom handler to partially update theme fields.
     * Partial update for theme configuration
     */
    async instancesOpenedxConfigThemeConfigRaw(requestParameters: InstancesOpenedxConfigThemeConfigRequest): Promise<runtime.ApiResponse<ThemeSchema>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxConfigThemeConfig.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling instancesOpenedxConfigThemeConfig.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/{id}/theme_config/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: ThemeSchemaToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => ThemeSchemaFromJSON(jsonValue));
    }

    /**
     * This is a custom handler to partially update theme fields.
     * Partial update for theme configuration
     */
    async instancesOpenedxConfigThemeConfig(requestParameters: InstancesOpenedxConfigThemeConfigRequest): Promise<ThemeSchema> {
        const response = await this.instancesOpenedxConfigThemeConfigRaw(requestParameters);
        return await response.value();
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Update instance owned by user
     */
    async instancesOpenedxConfigUpdateRaw(requestParameters: InstancesOpenedxConfigUpdateRequest): Promise<runtime.ApiResponse<OpenEdXInstanceConfig>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxConfigUpdate.');
        }

        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling instancesOpenedxConfigUpdate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OpenEdXInstanceConfigToJSON(requestParameters.data),
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenEdXInstanceConfigFromJSON(jsonValue));
    }

    /**
     * Open edX Instance Configuration API.  This API can be used to manage the configuration for Open edX instances owned by clients.
     * Update instance owned by user
     */
    async instancesOpenedxConfigUpdate(requestParameters: InstancesOpenedxConfigUpdateRequest): Promise<OpenEdXInstanceConfig> {
        const response = await this.instancesOpenedxConfigUpdateRaw(requestParameters);
        return await response.value();
    }

    /**
     * This action is publicly accessible and allows any user to validate an instance configuration. It is useful when signing up.
     * Validate instance configuration
     */
    async instancesOpenedxConfigValidateRaw(requestParameters: InstancesOpenedxConfigValidateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling instancesOpenedxConfigValidate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_config/validate/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenEdXInstanceConfigToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This action is publicly accessible and allows any user to validate an instance configuration. It is useful when signing up.
     * Validate instance configuration
     */
    async instancesOpenedxConfigValidate(requestParameters: InstancesOpenedxConfigValidateRequest): Promise<void> {
        await this.instancesOpenedxConfigValidateRaw(requestParameters);
    }

    /**
     * This API call will copy over any changes made to the instance config to the actual instance used to launch AppServers and launch a new AppServer with the applied changes.  It checks if an AppServer is already being provisioned and in that case prevents a new one from being launched unless forced.
     * Commit configuration changes to instance and launch new AppServer.
     */
    async instancesOpenedxDeploymentCreateRaw(requestParameters: InstancesOpenedxDeploymentCreateRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.data === null || requestParameters.data === undefined) {
            throw new runtime.RequiredError('data','Required parameter requestParameters.data was null or undefined when calling instancesOpenedxDeploymentCreate.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        if (requestParameters.force !== undefined) {
            queryParameters['force'] = requestParameters.force;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_deployment/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OpenEdXInstanceDeploymentCreateToJSON(requestParameters.data),
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This API call will copy over any changes made to the instance config to the actual instance used to launch AppServers and launch a new AppServer with the applied changes.  It checks if an AppServer is already being provisioned and in that case prevents a new one from being launched unless forced.
     * Commit configuration changes to instance and launch new AppServer.
     */
    async instancesOpenedxDeploymentCreate(requestParameters: InstancesOpenedxDeploymentCreateRequest): Promise<void> {
        await this.instancesOpenedxDeploymentCreateRaw(requestParameters);
    }

    /**
     * This allows the user to cancel an ongoing deployment, note that this can can cancel both user-triggered deployments and OpenCraft triggered deployments.
     * Stops all current redeployments.
     */
    async instancesOpenedxDeploymentDeleteRaw(requestParameters: InstancesOpenedxDeploymentDeleteRequest): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxDeploymentDelete.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_deployment/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.VoidApiResponse(response);
    }

    /**
     * This allows the user to cancel an ongoing deployment, note that this can can cancel both user-triggered deployments and OpenCraft triggered deployments.
     * Stops all current redeployments.
     */
    async instancesOpenedxDeploymentDelete(requestParameters: InstancesOpenedxDeploymentDeleteRequest): Promise<void> {
        await this.instancesOpenedxDeploymentDeleteRaw(requestParameters);
    }

    /**
     * List method not allowed.
     */
    async instancesOpenedxDeploymentListRaw(): Promise<runtime.ApiResponse<Array<OpenEdXInstanceDeploymentStatus>>> {
        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_deployment/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(OpenEdXInstanceDeploymentStatusFromJSON));
    }

    /**
     * List method not allowed.
     */
    async instancesOpenedxDeploymentList(): Promise<Array<OpenEdXInstanceDeploymentStatus>> {
        const response = await this.instancesOpenedxDeploymentListRaw();
        return await response.value();
    }

    /**
     * This API will check for provisioning appservers or changes in settings that need to be deployed and return a status code to the frontend.
     * Retrieves the deployment status for a given betatest instance.
     */
    async instancesOpenedxDeploymentReadRaw(requestParameters: InstancesOpenedxDeploymentReadRequest): Promise<runtime.ApiResponse<OpenEdXInstanceDeploymentStatus>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling instancesOpenedxDeploymentRead.');
        }

        const queryParameters: runtime.HTTPQuery = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // api_key authentication
        }

        if (this.configuration && (this.configuration.username !== undefined || this.configuration.password !== undefined)) {
            headerParameters["Authorization"] = "Basic " + btoa(this.configuration.username + ":" + this.configuration.password);
        }
        const response = await this.request({
            path: `/v2/instances/openedx_deployment/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => OpenEdXInstanceDeploymentStatusFromJSON(jsonValue));
    }

    /**
     * This API will check for provisioning appservers or changes in settings that need to be deployed and return a status code to the frontend.
     * Retrieves the deployment status for a given betatest instance.
     */
    async instancesOpenedxDeploymentRead(requestParameters: InstancesOpenedxDeploymentReadRequest): Promise<OpenEdXInstanceDeploymentStatus> {
        const response = await this.instancesOpenedxDeploymentReadRaw(requestParameters);
        return await response.value();
    }

}
