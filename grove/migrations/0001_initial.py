# Generated by Django 2.2.24 on 2021-12-03 11:29

from django.conf import settings
import django.contrib.postgres.fields
import django.contrib.postgres.fields.jsonb
from django.db import migrations, models
import django.db.models.deletion
import django_extensions.db.fields
import functools
import grove.models.repository
import instance.models.mixins.openedx_monitoring
import instance.models.utils
import instance.schemas.theming


class Migration(migrations.Migration):

    initial = True

    dependencies = [
        ('instance', '0144_make_redis_username_unique'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        migrations.CreateModel(
            name='GroveClusterRepository',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('created', django_extensions.db.fields.CreationDateTimeField(auto_now_add=True, verbose_name='created')),
                ('modified', django_extensions.db.fields.ModificationDateTimeField(auto_now=True, verbose_name='modified')),
                ('name', models.CharField(help_text='Descriptive name of the repository. E.g. P&T clients.', max_length=255, unique=True)),
                ('project_id', models.PositiveIntegerField(help_text='GitLab project ID of the repository.', unique=True)),
                ('unleash_instance_id', models.CharField(help_text='Instance ID of the unleash setup, obtained from GitLab.', max_length=255)),
                ('git_ref', models.CharField(help_text='Git branch or tag on the repository to use when triggering pipelines.', max_length=255)),
                ('trigger_token', models.CharField(help_text='GitLab token used to trigger pipeline builds.', max_length=255)),
            ],
            options={
                'verbose_name_plural': 'Grove cluster repositories',
                'ordering': ['name'],
            },
        ),
        migrations.CreateModel(
            name='GroveDeployment',
            fields=[
                ('deployment_ptr', models.OneToOneField(auto_created=True, on_delete=django.db.models.deletion.CASCADE, parent_link=True, primary_key=True, serialize=False, to='instance.Deployment')),
                ('overrides', django.contrib.postgres.fields.jsonb.JSONField(blank=True, null=True)),
            ],
            options={
                'ordering': ('-modified', '-created'),
                'get_latest_by': 'modified',
                'abstract': False,
            },
            bases=('instance.deployment',),
        ),
        migrations.CreateModel(
            name='GroveInstance',
            fields=[
                ('id', models.AutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('internal_lms_domain', models.CharField(max_length=100, unique=True)),
                ('internal_lms_preview_domain', models.CharField(max_length=100, unique=True)),
                ('internal_studio_domain', models.CharField(max_length=100, unique=True)),
                ('internal_discovery_domain', models.CharField(max_length=100, unique=True)),
                ('internal_ecommerce_domain', models.CharField(max_length=100, unique=True)),
                ('external_lms_domain', models.CharField(blank=True, max_length=100)),
                ('external_lms_preview_domain', models.CharField(blank=True, max_length=100)),
                ('external_studio_domain', models.CharField(blank=True, max_length=100)),
                ('external_discovery_domain', models.CharField(blank=True, max_length=100)),
                ('external_ecommerce_domain', models.CharField(blank=True, max_length=100)),
                ('extra_custom_domains', models.TextField(blank=True, default='', help_text='Add custom domain names, one per line. Domain names must be sub domains of the main LMS domain.')),
                ('enable_prefix_domains_redirect', models.BooleanField(default=False)),
                ('openstack_region', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('OPENSTACK_REGION',), **{}), max_length=16)),
                ('deploy_simpletheme', models.BooleanField(default=False, help_text='If set to True, new appservers will use theme settings from the beta application form, if available. A basic theme will be deployed through simple_theme and it may  change colors and images. If set to False, no theme will be created and the default Open edX theme will be used; this is recommended for instances registered before the theme fields were available.', verbose_name='Deploy simple_theme')),
                ('theme_config', django.contrib.postgres.fields.jsonb.JSONField(blank=True, help_text='The final theme configuration data committed by the user for deployment. This should be picked up by appservers launched for this instance', null=True, validators=[instance.schemas.theming.theme_schema_validate], verbose_name='Final Theme Configuration JSON')),
                ('email', models.EmailField(default='contact@example.com', help_text='The default contact email for this instance; also used as the from address for emails sent by the server.', max_length=254)),
                ('privacy_policy_url', models.URLField(blank=True, default='', help_text='URL to the privacy policy.', verbose_name='URL to Privacy Policy')),
                ('openedx_release', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('DEFAULT_OPENEDX_RELEASE',), **{}), help_text='Set this to a release tag like "named-release/dogwood" to build a specific release of Open edX. This setting becomes the default value for edx_platform_version, forum_version, notifier_version, xqueue_version, and certs_version so it should be a git branch that exists in all of those repositories. Note: to build a specific branch of edx-platform, you should just override edx_platform_commit rather than changing this setting. Note 2: This value does not affect the default value of configuration_version.', max_length=128)),
                ('configuration_source_repo_url', models.URLField(default=functools.partial(instance.models.utils._get_setting, *('DEFAULT_CONFIGURATION_REPO_URL',), **{}), max_length=256)),
                ('configuration_version', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('DEFAULT_CONFIGURATION_VERSION',), **{}), max_length=50)),
                ('configuration_extra_settings', models.TextField(blank=True, help_text='YAML config vars that override all others')),
                ('configuration_playbook_name', models.CharField(blank=True, max_length=100)),
                ('edx_platform_repository_url', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('DEFAULT_EDX_PLATFORM_REPO_URL',), **{}), help_text='URL to the edx-platform repository to use. Leave blank for default.', max_length=256)),
                ('edx_platform_commit', models.CharField(help_text='edx-platform commit hash or branch or tag to use. Leave blank to use the default, which is equal to the value of "openedx_release".', max_length=256)),
                ('ansible_appserver_repo_url', models.URLField(default=functools.partial(instance.models.utils._get_setting, *('ANSIBLE_APPSERVER_REPO',), **{}), help_text='The repository to pull the default Ansible playbook from.', max_length=256)),
                ('ansible_appserver_playbook', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('ANSIBLE_APPSERVER_PLAYBOOK',), **{}), help_text='The path to the common appserver playbook to run on all appservers.', max_length=256)),
                ('ansible_appserver_requirements_path', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('ANSIBLE_APPSERVER_REQUIREMENTS_PATH',), **{}), help_text='The path to the requirements file for the common appserver playbook.', max_length=256)),
                ('ansible_appserver_version', models.CharField(default=functools.partial(instance.models.utils._get_setting, *('ANSIBLE_APPSERVER_VERSION',), **{}), help_text='The version of the Ansible playbook repository to checkout.', max_length=256)),
                ('openstack_server_flavor', django.contrib.postgres.fields.jsonb.JSONField(blank=True, default=functools.partial(instance.models.utils._get_setting, *('OPENSTACK_SANDBOX_FLAVOR',), **{}), help_text='JSON openstack flavor selector, e.g. {"name": "vps-ssd-1"}. Defaults to settings.OPENSTACK_SANDBOX_FLAVOR on server creation.', null=True)),
                ('openstack_server_base_image', django.contrib.postgres.fields.jsonb.JSONField(blank=True, default=functools.partial(instance.models.utils._get_setting, *('OPENSTACK_SANDBOX_BASE_IMAGE',), **{}), help_text='JSON openstack base image selector, e.g. {"name": "focal-20.04-unmodified"} Defaults to settings.OPENSTACK_SANDBOX_BASE_IMAGE on server creation.', null=True)),
                ('openstack_server_ssh_keyname', models.CharField(blank=True, default=functools.partial(instance.models.utils._get_setting, *('OPENSTACK_SANDBOX_SSH_KEYNAME',), **{}), help_text='SSH key name used when setting up access to the openstack project. Defaults to settings.OPENSTACK_SANDBOX_SSH_KEYNAME on server creation.', max_length=256, null=True)),
                ('additional_security_groups', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=200), blank=True, default=list, help_text="Optional: A list of extra OpenStack security group names to use for this instance's VMs. A typical use case is to grant this instance access to a private database server that is behind a firewall. (In the django admin, separate group names with a comma.)", size=None)),
                ('additional_monitoring_emails', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=200), blank=True, default=list, help_text='Optional: A list of additional email addresses other than settings.ADMINS who should receive alerts from New Relic Synthetics Monitors when this instance becomes unavailable.', size=None)),
                ('provisioning_failure_notification_emails', django.contrib.postgres.fields.ArrayField(base_field=models.CharField(max_length=200), blank=True, default=list, help_text='Optional: A list of additional email addresses other than settings.ADMINS who should receive alerts when an AppServer fails to provision.', size=None)),
                ('openedx_appserver_count', models.IntegerField(default=1, help_text='The number of Open edX AppServers to deploy for this instance.')),
                ('lms_users', models.ManyToManyField(blank=True, help_text='Instance manager users that should be made staff users on the instance.', to=settings.AUTH_USER_MODEL)),
                ('repository', models.ForeignKey(default=grove.models.repository.get_default_repository, help_text='Repository in GitLab in which the instance is defined.', null=True, on_delete=django.db.models.deletion.SET_NULL, to='grove.GroveClusterRepository')),
                ('tags', models.ManyToManyField(blank=True, help_text='Custom tags associated with the instance.', to='instance.InstanceTag')),
            ],
            options={
                'abstract': False,
            },
            bases=(instance.models.mixins.openedx_monitoring.OpenEdXMonitoringMixin, instance.models.utils.ValidateModelMixin, models.Model),
        ),
    ]
